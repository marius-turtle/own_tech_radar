name,ring,quadrant,isNew,description
React Hooks,Adopt,languages-and-frameworks,FALSE,"<p><strong><a href=""https://reactjs.org/docs/hooks-intro.html"">React Hooks</a></strong> have introduced a new approach to managing stateful logic; given React components have always been closer to functions than classes, Hooks have embraced this and brought state to the functions, instead of using classes to take function to the state with methods. Another staple of state management in React applications is <a href=""/radar/languages-and-frameworks/redux"">Redux</a>, and we've already noted that it has come under scrutiny, suggesting that sometimes the complexity of Redux isn't worth it and in such cases a simple approach using Hooks is preferable. Rolling this completely on your own can quickly become tricky; therefore we recommend considering a combination of <a href=""https://reactjs.org/docs/context.html"">React Context</a> and the useContext and useReducer hooks, along the lines explained in this <a href=""https://blog.logrocket.com/guide-to-react-usereducer-hook/"">blog post</a>.</p>"
React Native Reanimated 2.0,Trial,languages-and-frameworks,TRUE,"<p>If we want animations in <a href=""/radar/languages-and-frameworks/react-native"">React Native</a> applications, <strong><a href=""https://docs.swmansion.com/react-native-reanimated/"">React Native Reanimated 2.0</a></strong> is the way to go. We previously had Reanimated 1.x, but it had issues related to the complexity of the Reanimated declarative language and also had some additional performance costs related to initialization and communication between the React Native JavaScript thread and the UI thread. Reanimated 2.0 is an attempt at reimagining how to run animations in the UI thread; it allows us to code the animations in JavaScript and run them on the UI thread using a new API called <a href=""https://docs.swmansion.com/react-native-reanimated/docs/2.2.0/worklets/"">animation worklets</a>. It does this by spawning a secondary JavaScript context on the UI thread that then is able to run JavaScript functions. We're using it in our React Native projects which need animations and like it a lot.</p>"
React Query,Trial,languages-and-frameworks,TRUE,"<p><a href=""https://react-query.tanstack.com/""><strong>React Query</strong></a> is often described as the missing data-fetching library for React. Fetching, caching, synchronizing and updating server state is a common requirement in many React applications, and although the requirements are well-understood, getting the implementation right is notoriously difficult. React Query provides a straightforward solution using hooks. As an application developer you simply pass a function that resolves your data and leave everything else to the framework. We like that it works out-of-the-box but still offers a lot of configuration when needed. The developer tools, unfortunately not yet available for React Native, do help with understanding of how the framework works, which benefits developers new to it. In our experience, version 3 of the framework brought the stability needed to be used in production with our clients.</p>"
React Three Fiber,Assess,languages-and-frameworks,TRUE,"<p>With the rising interest in — and viability of — 3D and extended reality (XR) applications in web browsers, our teams have been experimenting with <a href=""https://github.com/pmndrs/react-three-fiber""><strong>React Three Fiber</strong></a> for developing 3D experiences on the web. React Three Fiber is a library that takes the React.js component and state model and translates it to 3D objects rendered with the <a href=""/radar/languages-and-frameworks/three-js"">Three.js</a> library. This approach opens up 3D web programming to the wider group of developers already familiar with React.js and the rich ecosystem of tools and libraries surrounding it. However, when developing applications with React Three Fiber, our teams often have to manipulate the 3D scene imperatively. This doesn't mix well with the reactive component paradigm provided by React. There is no escaping the need to understand the basic 3D rendering mechanisms. The jury is still out on whether React Three Fiber offers enough abstraction to warrant learning its idiosyncrasies or if it's better just to work with Three.js directly.</p>"
Four key metrics,Trial,Techniques,FALSE,"<p>To measure software delivery performance, more and more organizations are turning to the <strong>four key metrics</strong> as defined by the <a href=""https://www.devops-research.com/"">DORA research</a> program: change lead time, deployment frequency, mean time to restore (MTTR) and change fail percentage. This research and its statistical analysis have shown a clear link between high delivery performance and these metrics; they provide a great leading indicator for how a team, or even a whole delivery organization, is doing.</p>

<p>We're still big proponents of these metrics, but we've also learned some lessons since we first started monitoring them. And we're increasingly seeing misguided measurement approaches with tools that help teams measure these metrics based purely on their continuous delivery (CD) pipelines. In particular when it comes to the stability metrics (MTTR and change fail percentage), CD pipeline data alone doesn't provide enough information to determine what a deployment failure with real user impact is. Stability metrics only make sense if they include data about real incidents that degrade service for the users.</p>

<p>And as with all metrics, we recommend to always keep in mind the ultimate intention behind a measurement and use them to reflect and learn. For example, before spending weeks to build up sophisticated dashboard tooling, consider just regularly taking the <a href=""https://www.devops-research.com/quickcheck.html"">DORA quick check</a> in team retrospectives. This gives the team the opportunity to reflect on which <a href=""https://www.devops-research.com/research.html#capabilities"">capabilities</a> they could work on to improve their metrics, which can be much more effective than overdetailed out-of-the-box tooling.</p>"
K3s,Trial,Platforms,FALSE,"<p><a href=""https://k3s.io/""><strong>K3s</strong></a> is a lightweight Kubernetes distribution built for IoT and edge computing. You get the benefits of a fully compliant Kubernetes but with reduced operational overhead. Its enhancements include lightweight storage backends (<a href=""https://docs.python.org/3/library/sqlite3.html"">sqlite3</a> as default instead of <a href=""https://etcd.io/"">etcd</a>), a single binary package with minimal OS dependencies and reduced memory footprint, all of which make K3s suitable for resource-constrained environments. We've used K3s in point-of-sale machines, and we're quite happy with our decision.</p>"
Pulumi,Trial,Platforms,FALSE,"<p>We've been seeing an increase in teams using <strong><a href=""https://pulumi.io/"">Pulumi</a></strong> in various organizations. Pulumi fills a gaping hole in the infrastructure coding world where <a href=""/radar/tools/terraform"">Terraform</a> maintains a firm hold. While Terraform is a tried-and-true standby, its declarative nature suffers from inadequate abstraction facilities and limited testability. Terraform is adequate when the infrastructure is entirely static, but dynamic infrastructure definitions call for a real programming language. Pulumi distinguishes itself by allowing configurations to be written in <a href=""/radar/languages-and-frameworks/typescript"">TypeScript</a>/JavaScript, <a href=""/radar/languages-and-frameworks/python-3"">Python</a> and <a href=""/radar/languages-and-frameworks/go-language"">Go</a> — no markup language or templating required. Pulumi is tightly focused on cloud-native architectures — including containers, serverless functions and data services — and provides good support for <a href=""/radar/platforms/kubernetes"">Kubernetes</a>. Recently, <a href=""/radar/platforms/aws-cloud-development-kit"">AWS CDK</a> has mounted a challenge, but Pulumi remains the only cloud-neutral tool in this area.</p>"
Three.js,Trial,languages-and-frameworks,FALSE,"<p>We first mentioned <strong><a href=""https://threejs.org/"">Three.js</a></strong> in the Radar in Assess back in 2017. Since then, this 3D rendering library for the web has evolved and improved rapidly. The standard WebGL APIs have improved, and Three.js has added support for WebXR, turning it into a viable tool for creating immersive experiences. At the same time, browser support for 3D rendering and WebXR device APIs has improved, making the web an increasingly attractive platform for 3D content. Although there are other 3D rendering libraries, our teams have come to prefer Three.js, especially when paired with <a href=""/radar/languages-and-frameworks/react-three-fiber"">React Three Fiber</a> to abstract away some of the low-level details. We've found that developers still need to be conscious of performance issues and will sometimes need to restructure data to optimize rendering speed.</p>"
Podman,Trial,Tools,TRUE,"<p><strong><a href=""https://ngneat.github.io/transloco/"">Transloco</a></strong> is a library for Angular to build multilingual applications. It can be used in templates and offers a function to cover more complex use cases. Because the translations are loaded on-demand at run time, Transloco makes it easy to implement language switching in the web browser. It also covers localization of numbers, dates and more using template pipes.</p>"
Colima,Trial,Tools,TRUE,